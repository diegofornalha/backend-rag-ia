# Debugging de Documentos no Supabase

## Problema

Documentos existentes no Supabase não estão sendo contabilizados corretamente na API.

## Etapas de Verificação

### 1. Verificação Inicial

```python
# Criar script debug_supabase.py para verificar:
# - Conexão com Supabase
# - Contagem de documentos
# - Contagem de embeddings
# - Joins entre documentos e embeddings
```

### 2. Queries de Diagnóstico

```sql
-- Verificar documentos
SELECT COUNT(*) FROM documents;

-- Verificar embeddings
SELECT COUNT(*) FROM embeddings;

-- Verificar relacionamentos
SELECT d.id, d.content, e.id as embedding_id
FROM documents d
LEFT JOIN embeddings e ON d.id = e.document_id;
```

### 3. Pontos de Verificação

1. Variáveis de ambiente corretas
2. Conexão Supabase estabelecida
3. Permissões das tabelas
4. Integridade dos dados
5. Relacionamentos entre tabelas

## Instruções para o Composer

1. **Verificar Conexão**

```python
# Testar conexão com Supabase
supabase = create_client(supabase_url, supabase_key)
response = supabase.table("documents").select("*").execute()
```

2. **Verificar Documentos**

```python
# Testar diferentes métodos de contagem
count_direct = len(response.data)
count_exact = response.count
```

3. **Verificar Embeddings**

```python
# Testar integridade dos embeddings
embeddings = supabase.table("embeddings").select("*").execute()
```

4. **Logs e Monitoramento**

```python
# Adicionar logs detalhados
logger.info(f"Documentos encontrados: {count_direct}")
logger.info(f"Embeddings encontrados: {len(embeddings.data)}")
```

## Soluções Possíveis

### Abordagem 1: Reindexação

```python
# Recriar índices e relacionamentos
async def reindex_documents():
    documents = supabase.table("documents").select("*").execute()
    for doc in documents.data:
        await update_document_embedding(doc)
```

### Abordagem 2: Verificação de Integridade

```python
# Verificar e corrigir inconsistências
async def check_integrity():
    docs_without_embeddings = supabase.table("documents")\
        .select("*")\
        .is_("embedding_id", "null")\
        .execute()
    for doc in docs_without_embeddings.data:
        await regenerate_embedding(doc)
```

### Abordagem 3: Recriação de Tabelas

```sql
-- Apenas se necessário, fazer backup antes
DROP TABLE IF EXISTS embeddings;
DROP TABLE IF EXISTS documents;

-- Recriar tabelas com estrutura correta
CREATE TABLE documents (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content TEXT NOT NULL,
    metadata JSONB,
    embedding_id INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE embeddings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    document_id BIGINT REFERENCES documents(id),
    embedding vector(384),
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

## Instruções para Execução

1. Execute o script de diagnóstico
2. Analise os logs e resultados
3. Escolha a abordagem mais apropriada
4. Implemente a solução
5. Verifique novamente a contagem
6. Atualize a documentação

## Notas Importantes

- Fazer backup antes de alterações estruturais
- Manter logs detalhados durante o processo
- Verificar impacto em outras funcionalidades
- Documentar todas as alterações realizadas

## Atualização do Health Check

Após a correção, atualizar o endpoint de health check para incluir verificações mais robustas:

```python
@app.get("/api/v1/health")
async def health_check():
    return {
        "status": "healthy",
        "documents_count": count,
        "embeddings_count": embeddings_count,
        "documents_with_embeddings": joined_count,
        "last_check": datetime.now().isoformat()
    }
```

## Monitoramento Contínuo

Implementar alertas para:

- Discrepâncias entre documentos e embeddings
- Falhas na geração de embeddings
- Erros de integridade referencial
- Problemas de performance em queries

---

**Observação**: Este documento deve ser mantido atualizado com quaisquer novos problemas encontrados e suas respectivas soluções.
