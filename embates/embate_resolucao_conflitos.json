{
  "titulo": "Sistema de Resolução de Conflitos para Embates",
  "version_key": "resolucao_conflitos_v1",
  "conteudo": "# Sistema de Resolução de Conflitos para Embates\n\n## Contexto\nAtualmente, quando existem conflitos (como diretórios duplicados ou inconsistências), não há um processo automatizado para resolvê-los. Isso resulta em problemas como os diretórios de embates em três locais diferentes.\n\n## Análise do Problema\n\n### 1. Tipos de Conflitos\n1. **Diretórios Duplicados**\n   - Múltiplos locais para mesma finalidade\n   - Inconsistência na escolha do local\n   - Dificuldade de manutenção\n\n2. **Conflitos de Versão**\n   - Mesmo embate em diferentes estados\n   - Histórico fragmentado\n   - Dificuldade de rastreamento\n\n3. **Conflitos de Propósito**\n   - Ambiguidade na finalidade\n   - Sobreposição de responsabilidades\n   - Falta de clareza\n\n## Solução Proposta\n\n### 1. Sistema de Detecção\n```python
class ConflictDetector:
    def __init__(self):
        self.known_locations = [\"/embates/\", \"/dados_embates/\", \"/cli/dados/embates/\"]
        
    def check_directory_conflicts(self) -> list:
        \"\"\"Verifica conflitos de diretório\"\"\"
        conflicts = []
        for location in self.known_locations:
            if os.path.exists(location):
                conflicts.append({
                    \"tipo\": \"diretorio\",
                    \"local\": location,
                    \"conteudo\": os.listdir(location)
                })
        return conflicts
    
    def check_version_conflicts(self, embate_id: str) -> list:
        \"\"\"Verifica conflitos de versão\"\"\"
        versions = []
        for location in self.known_locations:
            path = os.path.join(location, f\"embate_{embate_id}.json\")
            if os.path.exists(path):
                with open(path) as f:
                    versions.append({
                        \"local\": location,
                        \"data\": json.load(f)
                    })
        return versions if len(versions) > 1 else []
```\n\n### 2. Sistema de Resolução\n```python
class ConflictResolver:
    def __init__(self, detector: ConflictDetector):
        self.detector = detector
        self.manager = EmbateManager()  # Usa o gerenciador existente
        
    def resolve_directory_conflict(self):
        \"\"\"Resolve conflitos de diretório\"\"\"
        conflicts = self.detector.check_directory_conflicts()
        if not conflicts:
            return
            
        for conflict in conflicts:
            # Determina o destino correto baseado no tipo/propósito
            if self._is_temporary_data(conflict):
                dest_type = \"temp\"
                dest_subdir = self._get_appropriate_subdir(conflict)
            else:
                dest_type = \"principal\"
                dest_subdir = self._get_appropriate_subdir(conflict)
                
            # Move os arquivos para o local correto
            self._migrate_files(conflict, dest_type, dest_subdir)
            
    def resolve_version_conflict(self, embate_id: str):
        \"\"\"Resolve conflitos de versão\"\"\"
        versions = self.detector.check_version_conflicts(embate_id)
        if not versions:
            return
            
        # Encontra a versão mais recente/válida
        latest = self._find_latest_version(versions)
        
        # Move para local correto e remove outras versões
        self._consolidate_versions(latest, versions)
        
    def _is_temporary_data(self, conflict) -> bool:
        \"\"\"Determina se os dados são temporários\"\"\"
        # Implementar lógica de detecção
        pass
        
    def _get_appropriate_subdir(self, conflict) -> str:
        \"\"\"Determina o subdiretório apropriado\"\"\"
        # Implementar lógica de classificação
        pass
        
    def _migrate_files(self, conflict, dest_type: str, dest_subdir: str):
        \"\"\"Migra arquivos para o local correto\"\"\"
        for file in conflict[\"conteudo\"]:
            with open(os.path.join(conflict[\"local\"], file)) as f:
                embate = json.load(f)
            
            # Usa o EmbateManager para salvar no local correto
            self.manager.save_embate(embate, dest_type, dest_subdir)
            
            # Remove arquivo original após migração
            os.remove(os.path.join(conflict[\"local\"], file))
```\n\n### 3. Integração com CLI\n```python
@click.command()
@click.option('--check-only', is_flag=True, help='Apenas verifica conflitos sem resolver')
def resolve_conflicts(check_only: bool):
    \"\"\"Comando CLI para resolver conflitos\"\"\"
    detector = ConflictDetector()
    resolver = ConflictResolver(detector)
    
    # Verifica conflitos
    dir_conflicts = detector.check_directory_conflicts()
    if dir_conflicts:
        click.echo(f\"Encontrados {len(dir_conflicts)} conflitos de diretório\")
        if not check_only:
            resolver.resolve_directory_conflicts()
            click.echo(\"Conflitos resolvidos\")
    
    # Implementar verificação de outros tipos de conflito
```\n\n## Processo de Resolução\n\n1. **Detecção**\n   - Verificação automática de conflitos\n   - Identificação do tipo de conflito\n   - Análise de impacto\n\n2. **Classificação**\n   - Determinar propósito dos dados\n   - Identificar destino correto\n   - Avaliar prioridades\n\n3. **Migração**\n   - Mover dados para local correto\n   - Preservar metadados importantes\n   - Validar integridade\n\n4. **Limpeza**\n   - Remover dados duplicados\n   - Atualizar referências\n   - Documentar mudanças\n\n## Benefícios\n\n1. **Consistência**\n   - Estrutura unificada\n   - Processo padronizado\n   - Menos confusão\n\n2. **Automação**\n   - Detecção proativa\n   - Resolução automática\n   - Menos erros humanos\n\n3. **Manutenção**\n   - Facilidade de gestão\n   - Rastreabilidade clara\n   - Processo documentado\n\n## Status\nEm análise - Aguardando revisão e aprovação para implementação do sistema de resolução de conflitos.",
  "error_log": null,
  "metadata": {
    "status": "aberto",
    "tipo": "tecnico",
    "tags": ["conflitos", "automacao", "resolucao", "organizacao", "embates"]
  }
} 