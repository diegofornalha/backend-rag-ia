# Migração de JSON para Supabase

## 1. Preparação do Ambiente Supabase

- Criar projeto no Supabase
- Configurar as políticas de segurança
- Adicionar variáveis de ambiente necessárias no projeto atual (referência em `.env`)

## 2. Modelagem do Banco de Dados

### Criar tabelas principais:

- `documents` (conteúdo principal)
- `metadata_global` (metadados globais)
- `document_metadata` (metadados específicos)
- `embeddings` (vetores para busca semântica)

### Criar relacionamentos:

- Chaves estrangeiras apropriadas
- Índices para otimização

## 3. Migração de Dados

- Criar script de migração para converter dados dos JSONs atuais (referência em `documents/*.json`)
- Implementar processo de upload em batch
- Validar integridade dos dados migrados
- Manter backup dos dados originais

## 4. Adaptação do VectorStore

- Modificar a classe VectorStore (referência em `services/vector_store.py`)

### Implementar novos métodos:

- Conexão com Supabase
- Cache local para otimização
- Gestão de batch para operações em massa
- Sistema de fallback

## 5. Otimizações

- Implementar sistema de cache
- Configurar pooling de conexões
- Adicionar paginação
- Implementar busca vetorial híbrida (Supabase + FAISS)

## 6. Atualizações na API

- Modificar rotas existentes (referência em `api/routes.py`)
- Implementar novos endpoints necessários
- Atualizar documentação da API
- Adicionar validações específicas para Supabase

## 7. Monitoramento

- Verificar logs do Supabase
- Monitorar performance das queries
- Acompanhar uso de recursos

## 8. Manutenção

- Backup regular dos dados
- Atualização das dependências
- Otimização de queries quando necessário

## 9. Testes

- Atualizar testes existentes
- Criar novos testes de integração
- Implementar testes de performance
- Configurar ambiente de testes isolado

## 10. Documentação

- Atualizar README
- Documentar nova estrutura
- Criar guias de troubleshooting
- Atualizar documentação da API

## 11. Deploy

- Atualizar pipeline de CI/CD
- Configurar backups automáticos
- Implementar estratégia de rollback
- Configurar monitoramento em produção

> Esta abordagem mantém a funcionalidade existente enquanto migra gradualmente para o Supabase, permitindo rollback se necessário.

--

implementar a persistência no Supabase! Analisando o arquivo supabase.md (linhas 1-91), já existe um plano de migração estruturado. Vou mostrar como implementar:
Primeiro, vamos criar as tabelas no Supabase:
-- Tabela de documentos
CREATE TABLE documents (
id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
content TEXT NOT NULL,
metadata JSONB,
embedding_id INTEGER,
created_at TIMESTAMPTZ DEFAULT NOW(),
updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de embeddings
CREATE TABLE embeddings (
id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
document_id BIGINT REFERENCES documents(id),
embedding vector(384), -- Dimensão do modelo all-MiniLM-L6-v2
created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Índices
CREATE INDEX idx_documents_metadata ON documents USING gin (metadata);
CREATE INDEX idx_embeddings_vector ON embeddings USING ivfflat (embedding vector_cosine_ops);
Modificar a classe VectorStore para usar Supabase:
from supabase import create_client
import numpy as np

class VectorStore:
def **init**(self,
embedding_model: str = "all-MiniLM-L6-v2",
batch_size: int = 32): # Configuração Supabase
supabase_url = os.getenv("SUPABASE_URL")
supabase_key = os.getenv("SUPABASE_KEY")
self.supabase = create_client(supabase_url, supabase_key)

        # Configuração do modelo
        self.embedding_model = SentenceTransformer(embedding_model)
        self.batch_size = batch_size

    async def add_document(self, document: Document) -> None:
        try:
            # Gera embedding
            embedding = self.embedding_model.encode(document.content)

            # Insere documento
            doc_data = {
                "content": document.content,
                "metadata": document.metadata
            }
            doc = self.supabase.table("documents").insert(doc_data).execute()
            doc_id = doc.data[0]["id"]

            # Insere embedding
            embedding_data = {
                "document_id": doc_id,
                "embedding": embedding.tolist()
            }
            self.supabase.table("embeddings").insert(embedding_data).execute()

        except Exception as e:
            logger.error(f"Erro ao adicionar documento: {e}")
            raise

    async def search(self, query: str, k: int = 4) -> List[Document]:
        try:
            # Gera embedding da query
            query_embedding = self.embedding_model.encode(query)

            # Busca vetorial no Supabase
            results = self.supabase.rpc(
                'match_documents',
                {
                    'query_embedding': query_embedding.tolist(),
                    'match_threshold': 0.8,
                    'match_count': k
                }
            ).execute()

            # Converte resultados
            documents = []
            for item in results.data:
                doc = Document(
                    content=item['content'],
                    metadata=item['metadata']
                )
                documents.append(doc)

            return documents

        except Exception as e:
            logger.error(f"Erro na busca: {e}")
            return []

Criar função de busca vetorial no Supabase:
CREATE OR REPLACE FUNCTION match_documents(
query_embedding vector(384),
match_threshold float,
match_count int
)
RETURNS TABLE (
id bigint,
content text,
metadata jsonb,
similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
RETURN QUERY
SELECT
d.id,
d.content,
d.metadata,
1 - (e.embedding <=> query_embedding) as similarity
FROM documents d
JOIN embeddings e ON d.id = e.document_id
WHERE 1 - (e.embedding <=> query_embedding) > match_threshold
ORDER BY similarity DESC
LIMIT match_count;
END;

$$
;
Atualizar o arquivo de configuração (.env):
SUPABASE_URL=sua_url_do_supabase
SUPABASE_KEY=sua_chave_do_supabase
Benefícios desta implementação:
Persistência durável dos dados
Busca vetorial otimizada
Queries SQL complexas
Backup automático
Escalabilidade
$$
