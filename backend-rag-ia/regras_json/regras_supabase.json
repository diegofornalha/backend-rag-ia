{
  "metadata_global": {
    "language": "pt-BR",
    "tipo": "regra",
    "fonte": "REGRAS_SUPABASE.md",
    "data_criacao": "2024-12-29T18:09:22.525061",
    "categorias": [
      "regras",
      "supabase"
    ],
    "id": "7e046a551cbe29398ce39e07c2e53c39"
  },
  "document": {
    "content": "1. Preparação do Ambiente Supabase:\n- Criar projeto no Supabase\n- Configurar as políticas de segurança\n- Adicionar variáveis de ambiente necessárias no projeto atual (referência em `.env`)\n\nCriar tabelas principais::\n- `documents` (conteúdo principal)\n- `metadata_global` (metadados globais)\n- `document_metadata` (metadados específicos)\n- `embeddings` (vetores para busca semântica)\n\nCriar relacionamentos::\n- Chaves estrangeiras apropriadas\n- Índices para otimização\n\n3. Migração de Dados:\n- Criar script de migração para converter dados dos JSONs atuais (referência em `documents/*.json`)\n- Implementar processo de upload em batch\n- Validar integridade dos dados migrados\n- Manter backup dos dados originais\n\n4. Adaptação do VectorStore:\n- Modificar a classe VectorStore (referência em `services/vector_store.py`)\n\nImplementar novos métodos::\n- Conexão com Supabase\n- Cache local para otimização\n- Gestão de batch para operações em massa\n- Sistema de fallback\n\n5. Otimizações:\n- Implementar sistema de cache\n- Configurar pooling de conexões\n- Adicionar paginação\n- Implementar busca vetorial híbrida (Supabase + FAISS)\n\n6. Atualizações na API:\n- Modificar rotas existentes (referência em `api/routes.py`)\n- Implementar novos endpoints necessários\n- Atualizar documentação da API\n- Adicionar validações específicas para Supabase\n\n7. Monitoramento:\n- Verificar logs do Supabase\n- Monitorar performance das queries\n- Acompanhar uso de recursos\n\n8. Manutenção:\n- Backup regular dos dados\n- Atualização das dependências\n- Otimização de queries quando necessário\n\n9. Testes:\n- Atualizar testes existentes\n- Criar novos testes de integração\n- Implementar testes de performance\n- Configurar ambiente de testes isolado\n\n10. Documentação:\n- Atualizar README\n- Documentar nova estrutura\n- Criar guias de troubleshooting\n- Atualizar documentação da API\n\n11. Deploy:\n- Atualizar pipeline de CI/CD\n- Configurar backups automáticos\n- Implementar estratégia de rollback\n- Configurar monitoramento em produção\n> Esta abordagem mantém a funcionalidade existente enquanto migra gradualmente para o Supabase, permitindo rollback se necessário.\n--\n\nCriação das Tabelas:\n```sql\n-- Tabela de documentos\nCREATE TABLE documents (\nid BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\ncontent TEXT NOT NULL,\nmetadata JSONB,\nembedding_id INTEGER,\ncreated_at TIMESTAMPTZ DEFAULT NOW(),\nupdated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- Tabela de embeddings\nCREATE TABLE embeddings (\nid BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\ndocument_id BIGINT REFERENCES documents(id),\nembedding vector(384), -- Dimensão do modelo all-MiniLM-L6-v2\ncreated_at TIMESTAMPTZ DEFAULT NOW()\n);\n-- Índices\nCREATE INDEX idx_documents_metadata ON documents USING gin (metadata);\nCREATE INDEX idx_embeddings_vector ON embeddings USING ivfflat (embedding vector_cosine_ops);\n```\n\nImplementação da Classe VectorStore:\n```python\nfrom supabase import create_client\nimport numpy as np\nclass VectorStore:\ndef __init__(self,\nembedding_model: str = \"all-MiniLM-L6-v2\",\nbatch_size: int = 32):\n# Configuração Supabase\nsupabase_url = os.getenv(\"SUPABASE_URL\")\nsupabase_key = os.getenv(\"SUPABASE_KEY\")\nself.supabase = create_client(supabase_url, supabase_key)\n# Configuração do modelo\nself.embedding_model = SentenceTransformer(embedding_model)\nself.batch_size = batch_size\nasync def add_document(self, document: Document) -> None:\ntry:\n# Gera embedding\nembedding = self.embedding_model.encode(document.content)\n# Insere documento\ndoc_data = {\n\"content\": document.content,\n\"metadata\": document.metadata\n}\ndoc = self.supabase.table(\"documents\").insert(doc_data).execute()\ndoc_id = doc.data[0][\"id\"]\n# Insere embedding\nembedding_data = {\n\"document_id\": doc_id,\n\"embedding\": embedding.tolist()\n}\nself.supabase.table(\"embeddings\").insert(embedding_data).execute()\nexcept Exception as e:\nlogger.error(f\"Erro ao adicionar documento: {e}\")\nraise\nasync def search(self, query: str, k: int = 4) -> List[Document]:\ntry:\n# Gera embedding da query\nquery_embedding = self.embedding_model.encode(query)\n# Busca vetorial no Supabase\nresults = self.supabase.rpc(\n'match_documents',\n{\n'query_embedding': query_embedding.tolist(),\n'match_threshold': 0.8,\n'match_count': k\n}\n).execute()\n# Converte resultados\ndocuments = []\nfor item in results.data:\ndoc = Document(\ncontent=item['content'],\nmetadata=item['metadata']\n)\ndocuments.append(doc)\nreturn documents\nexcept Exception as e:\nlogger.error(f\"Erro na busca: {e}\")\nreturn []\n```\n\nFunção de Busca Vetorial no Supabase:\n```sql\nCREATE OR REPLACE FUNCTION match_documents(\nquery_embedding vector(384),\nmatch_threshold float,\nmatch_count int\n)\nRETURNS TABLE (\nid bigint,\ncontent text,\nmetadata jsonb,\nsimilarity float\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\nRETURN QUERY\nSELECT\nd.id,\nd.content,\nd.metadata,\n1 - (e.embedding <=> query_embedding) as similarity\nFROM documents d\nJOIN embeddings e ON d.id = e.document_id\nWHERE 1 - (e.embedding <=> query_embedding) > match_threshold\nORDER BY similarity DESC\nLIMIT match_count;\nEND;\n$$;\n```\n\nConfiguração do Ambiente:\nAtualizar o arquivo de configuração (.env):\n```\nSUPABASE_URL=sua_url_do_supabase\nSUPABASE_KEY=sua_chave_do_supabase\n```\n\nBenefícios da Implementação:\n1. Persistência durável dos dados\n2. Busca vetorial otimizada\n3. Queries SQL complexas\n4. Backup automático\n5. Escalabilidade",
    "metadata": {
      "type": "regra",
      "title": "REGRAS_SUPABASE",
      "autor": "sistema",
      "formato_original": "markdown",
      "tags": [
        "documentação",
        "regras",
        "supabase"
      ],
      "versao": "1.0"
    }
  }
}