#!/usr/bin/env python3
"""
Ferramenta CLI para verificar a conformidade do projeto.
Analisa c√≥digo fonte, SQL e configura√ß√µes em busca de inconsist√™ncias.
"""

import os
import json
import re
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.prompt import Confirm
from supabase import create_client, Client
from dotenv import load_dotenv

# Carrega vari√°veis de ambiente
load_dotenv()

# Configura console
console = Console()

class VerificadorConformidade:
    """Classe principal para verifica√ß√£o de conformidade."""
    
    def __init__(self):
        """Inicializa o verificador."""
        self.problemas: List[Dict] = []
        self.arquivos_verificados = 0
        self.diretorios_verificados = 0
        
        # Padr√µes para verifica√ß√£o
        self.padroes = {
            'schema_publico': r'(table\(["\'])(public\.|documents|embeddings)',
            'supabase_table': r'supabase\.table\(["\'](?!rag\.)',
            'schema_incorreto': r'(CREATE|ALTER|DROP)\s+TABLE(?!\s+rag\.)',
            'policy_incorreta': r'CREATE\s+POLICY(?!\s+ON\s+rag\.)',
        }
        
        # Diret√≥rios a ignorar
        self.ignorar_dirs = {'.git', '.venv', 'venv', '__pycache__', 'node_modules'}
        
        # Extens√µes a verificar
        self.extensoes = {'.py', '.sql', '.json', '.yml', '.yaml', '.md'}
    
    def verificar_arquivo(self, arquivo: Path) -> List[Dict]:
        """Verifica um arquivo em busca de problemas de conformidade."""
        problemas = []
        
        try:
            conteudo = arquivo.read_text(encoding='utf-8')
            
            # Verifica cada padr√£o
            for nome, padrao in self.padroes.items():
                matches = re.finditer(padrao, conteudo, re.MULTILINE)
                for match in matches:
                    problemas.append({
                        'arquivo': str(arquivo),
                        'linha': conteudo.count('\n', 0, match.start()) + 1,
                        'tipo': nome,
                        'trecho': match.group(0),
                        'contexto': conteudo.splitlines()[conteudo.count('\n', 0, match.start())]
                    })
            
            # Verifica√ß√µes espec√≠ficas por tipo de arquivo
            if arquivo.suffix == '.json':
                self.verificar_json(arquivo, conteudo, problemas)
            elif arquivo.suffix in {'.yml', '.yaml'}:
                self.verificar_yaml(arquivo, conteudo, problemas)
            
        except Exception as e:
            problemas.append({
                'arquivo': str(arquivo),
                'linha': 0,
                'tipo': 'erro_leitura',
                'trecho': str(e),
                'contexto': 'Erro ao ler arquivo'
            })
        
        return problemas
    
    def verificar_json(self, arquivo: Path, conteudo: str, problemas: List[Dict]) -> None:
        """Verifica problemas espec√≠ficos em arquivos JSON."""
        try:
            dados = json.loads(conteudo)
            
            # Verifica refer√™ncias a tabelas/schemas
            if isinstance(dados, dict):
                self._verificar_dict_recursivo(dados, arquivo, problemas)
                
        except json.JSONDecodeError as e:
            problemas.append({
                'arquivo': str(arquivo),
                'linha': e.lineno,
                'tipo': 'json_invalido',
                'trecho': e.msg,
                'contexto': 'JSON inv√°lido'
            })
    
    def verificar_yaml(self, arquivo: Path, conteudo: str, problemas: List[Dict]) -> None:
        """Verifica problemas espec√≠ficos em arquivos YAML."""
        try:
            import yaml
            dados = yaml.safe_load(conteudo)
            
            # Verifica refer√™ncias a tabelas/schemas
            if isinstance(dados, dict):
                self._verificar_dict_recursivo(dados, arquivo, problemas)
                
        except yaml.YAMLError as e:
            problemas.append({
                'arquivo': str(arquivo),
                'linha': getattr(e, 'problem_mark', {}).get('line', 0),
                'tipo': 'yaml_invalido',
                'trecho': str(e),
                'contexto': 'YAML inv√°lido'
            })
    
    def _verificar_dict_recursivo(self, dados: Dict, arquivo: Path, problemas: List[Dict]) -> None:
        """Verifica recursivamente um dicion√°rio em busca de problemas."""
        for chave, valor in dados.items():
            # Verifica refer√™ncias a tabelas/schemas nas chaves
            for nome, padrao in self.padroes.items():
                if re.search(padrao, str(chave)):
                    problemas.append({
                        'arquivo': str(arquivo),
                        'linha': 0,
                        'tipo': nome,
                        'trecho': chave,
                        'contexto': f'Chave: {chave}'
                    })
            
            # Verifica valores recursivamente
            if isinstance(valor, dict):
                self._verificar_dict_recursivo(valor, arquivo, problemas)
            elif isinstance(valor, list):
                for item in valor:
                    if isinstance(item, dict):
                        self._verificar_dict_recursivo(item, arquivo, problemas)
    
    def verificar_diretorio(self, diretorio: Path) -> None:
        """Verifica recursivamente um diret√≥rio."""
        try:
            for item in diretorio.iterdir():
                # Ignora diret√≥rios espec√≠ficos
                if item.is_dir():
                    if item.name not in self.ignorar_dirs:
                        self.diretorios_verificados += 1
                        self.verificar_diretorio(item)
                # Verifica apenas arquivos com extens√µes espec√≠ficas
                elif item.suffix in self.extensoes:
                    self.arquivos_verificados += 1
                    problemas = self.verificar_arquivo(item)
                    self.problemas.extend(problemas)
                    
        except Exception as e:
            console.print(f"\n[red]Erro ao verificar diret√≥rio {diretorio}: {str(e)}[/red]")
    
    def exibir_relatorio(self) -> None:
        """Exibe relat√≥rio dos problemas encontrados."""
        console.print("\n[bold]üìä Relat√≥rio de Conformidade[/bold]")
        console.print(f"\nDiret√≥rios verificados: {self.diretorios_verificados}")
        console.print(f"Arquivos verificados: {self.arquivos_verificados}")
        console.print(f"Problemas encontrados: {len(self.problemas)}")
        
        if not self.problemas:
            console.print("\n[green]‚ú® Nenhum problema de conformidade encontrado![/green]")
            return
        
        # Agrupa problemas por tipo
        problemas_por_tipo: Dict[str, List[Dict]] = {}
        for problema in self.problemas:
            tipo = problema['tipo']
            if tipo not in problemas_por_tipo:
                problemas_por_tipo[tipo] = []
            problemas_por_tipo[tipo].append(problema)
        
        # Cria tabela de problemas
        table = Table(title="\nProblemas Encontrados")
        table.add_column("Arquivo", style="cyan")
        table.add_column("Linha", style="magenta")
        table.add_column("Tipo", style="yellow")
        table.add_column("Trecho", style="red")
        table.add_column("Contexto", style="blue")
        
        for tipo, problemas in problemas_por_tipo.items():
            console.print(f"\n[bold]{tipo}[/bold] ({len(problemas)} ocorr√™ncias)")
            for p in problemas:
                table.add_row(
                    str(p['arquivo']),
                    str(p['linha']),
                    p['tipo'],
                    p['trecho'],
                    p['contexto']
                )
        
        console.print(table)
    
    def gerar_embate(self) -> Dict:
        """Gera um embate com os problemas encontrados e recomenda√ß√µes."""
        tipos_problemas = set(p['tipo'] for p in self.problemas)
        
        # Mapeamento de recomenda√ß√µes por tipo de problema
        recomendacoes = {
            'schema_publico': (
                "- Sempre use o schema 'rag.' ao inv√©s de 'public'\n"
                "- Substitua refer√™ncias diretas a 'documents' ou 'embeddings' por 'rag.01_base_conhecimento_regras_geral' e 'rag.02_embeddings_regras_geral'\n"
                "- Atualize queries para incluir o prefixo 'rag.'"
            ),
            'supabase_table': (
                "- Ao usar client.table(), sempre inclua o prefixo 'rag.'\n"
                "- Exemplo: client.table('rag.01_base_conhecimento_regras_geral')\n"
                "- Verifique se todas as chamadas de API incluem o schema correto"
            ),
            'schema_incorreto': (
                "- Em scripts SQL, sempre especifique 'rag.' antes do nome da tabela\n"
                "- Use 'CREATE TABLE rag.nome_tabela'\n"
                "- Use 'ALTER TABLE rag.nome_tabela'\n"
                "- Use 'DROP TABLE rag.nome_tabela'"
            ),
            'policy_incorreta': (
                "- Pol√≠ticas RLS devem ser criadas no schema 'rag'\n"
                "- Use 'CREATE POLICY nome_policy ON rag.nome_tabela'\n"
                "- Verifique se todas as pol√≠ticas existentes foram migradas"
            ),
            'erro_leitura': (
                "- Verifique a codifica√ß√£o do arquivo (deve ser UTF-8)\n"
                "- Verifique as permiss√µes de leitura\n"
                "- Verifique se o arquivo n√£o est√° corrompido"
            ),
            'json_invalido': (
                "- Valide o JSON usando uma ferramenta online\n"
                "- Verifique a sintaxe (v√≠rgulas, chaves, aspas)\n"
                "- Use um formatador de JSON"
            ),
            'yaml_invalido': (
                "- Valide o YAML usando uma ferramenta online\n"
                "- Verifique a indenta√ß√£o\n"
                "- Verifique a sintaxe (listas, dicion√°rios)"
            )
        }
        
        embate = {
            "titulo": "Verifica√ß√£o de Conformidade do Projeto",
            "tipo": "tecnico",
            "status": "aberto" if self.problemas else "resolvido",
            "contexto": (
                "Verifica√ß√£o autom√°tica de conformidade do projeto, "
                "buscando inconsist√™ncias no uso de schemas, tabelas e configura√ß√µes.\n\n"
                "Este embate serve como documenta√ß√£o hist√≥rica dos problemas encontrados "
                "e como guia para evitar problemas similares no futuro."
            ),
            "argumentos": [
                {
                    "autor": "verificador",
                    "tipo": "analise",
                    "conteudo": (
                        f"An√°lise realizada em {self.diretorios_verificados} diret√≥rios "
                        f"e {self.arquivos_verificados} arquivos.\n"
                        f"Foram encontrados {len(self.problemas)} problemas de conformidade "
                        f"nos seguintes aspectos: {', '.join(tipos_problemas)}."
                    )
                }
            ],
            "decisao": (
                "Necess√°rio corrigir as inconsist√™ncias encontradas" 
                if self.problemas else 
                "Projeto est√° em conformidade"
            ),
            "razao": (
                "Foram encontrados problemas que podem afetar a consist√™ncia do projeto"
                if self.problemas else
                "Todos os arquivos verificados est√£o seguindo os padr√µes estabelecidos"
            ),
            "data_inicio": datetime.now().isoformat(),
            "tags": ["conformidade", "verificacao", "qualidade", "schema_rag"],
            "recomendacoes_gerais": [
                "1. Sempre use o schema 'rag' para todas as opera√ß√µes no Supabase",
                "2. Mantenha um padr√£o consistente de nomenclatura de tabelas",
                "3. Documente altera√ß√µes de schema em migrations",
                "4. Use ferramentas de lint e formata√ß√£o de c√≥digo",
                "5. Execute esta verifica√ß√£o de conformidade regularmente",
                "6. Revise as pol√≠ticas RLS ao fazer altera√ß√µes no schema",
                "7. Mantenha backups antes de altera√ß√µes significativas",
                "8. Teste queries e opera√ß√µes em ambiente de desenvolvimento"
            ]
        }
        
        # Adiciona detalhes dos problemas e recomenda√ß√µes espec√≠ficas
        if self.problemas:
            detalhes = []
            recomendacoes_especificas = set()
            
            for p in self.problemas:
                detalhes.append(
                    f"- Arquivo: {p['arquivo']}\n"
                    f"  Linha: {p['linha']}\n"
                    f"  Tipo: {p['tipo']}\n"
                    f"  Trecho: {p['trecho']}\n"
                    f"  Contexto: {p['contexto']}"
                )
                
                # Adiciona recomenda√ß√µes espec√≠ficas para o tipo de problema
                if p['tipo'] in recomendacoes:
                    recomendacoes_especificas.add(recomendacoes[p['tipo']])
            
            embate["argumentos"].append({
                "autor": "verificador",
                "tipo": "detalhes",
                "conteudo": "\n".join(detalhes)
            })
            
            embate["argumentos"].append({
                "autor": "verificador",
                "tipo": "recomendacoes",
                "conteudo": (
                    "Recomenda√ß√µes espec√≠ficas para os problemas encontrados:\n\n" +
                    "\n\n".join(recomendacoes_especificas)
                )
            })
        
        return embate

def main() -> None:
    """Fun√ß√£o principal."""
    try:
        console.print("\n[bold]üîç Verificador de Conformidade[/bold]")
        
        # Inicializa verificador
        verificador = VerificadorConformidade()
        
        # Obt√©m diret√≥rio raiz do projeto
        raiz = Path(os.getenv("PROJECT_ROOT", "."))
        
        console.print(f"\nIniciando verifica√ß√£o em: {raiz}")
        
        # Executa verifica√ß√£o
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:
            task = progress.add_task("Verificando conformidade...", total=None)
            verificador.verificar_diretorio(raiz)
            progress.update(task, completed=True)
        
        # Exibe relat√≥rio
        verificador.exibir_relatorio()
        
        # Gera embate automaticamente
        console.print("\n[bold]üìù Gerando embate com resultados e recomenda√ß√µes...[/bold]")
        embate = verificador.gerar_embate()
        arquivo_embate = raiz / "embates" / "embate_conformidade.json"
        arquivo_embate.parent.mkdir(exist_ok=True)
        
        with open(arquivo_embate, 'w', encoding='utf-8') as f:
            json.dump(embate, f, indent=2, ensure_ascii=False)
        
        console.print(f"\n[green]‚úÖ Embate gerado em: {arquivo_embate}[/green]")
        console.print("\n[bold]‚ÑπÔ∏è O embate inclui recomenda√ß√µes para prevenir problemas similares no futuro[/bold]")
        
    except KeyboardInterrupt:
        console.print("\n\n[bold]üëã Verifica√ß√£o cancelada![/bold]")
    except Exception as e:
        console.print(f"\n[red]Erro inesperado: {str(e)}[/red]")

if __name__ == "__main__":
    main() 